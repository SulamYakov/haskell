--[x] Problem 1: Find the last element of a list. 

myLast :: [a] -> a
myLast [ ]    = error "no last element of empty list."  
myLast [x]    = x
myLast (_:xs) = myLast xs

--[x] Problem 2: Find the next-to-last element of a list.
 
myButLast :: [a] -> a
myButLast [ ]    = error "invalid input to myButLast."
myButLast [x]    = x
myButLast [x,_]  = x
myButLast (_:xs) = myButLast xs

--[x] Problem 3: Find the k-th element of a list.

myElementAt :: Int -> [a] -> a
myElementAt k = last . (take k)  

--[x] Problem 4: Find the number of elements in a list.

myLength :: [a] -> Int 
myLength [ ]    = 0
myLength (_:xs) = 1 + myLength xs

--[x] Problem 5: Reverse a list.

myReverse :: [a] -> [a]
myReverse [ ]    = [ ]
myReverse (x:xs) = myReverse xs ++ [x]
--A tail recursive solution to make this significantly faster in large cases. 
myReverse' :: [a] -> [a] -> [a]
myReverse' (x:xs) ys = myReverse' xs (x:ys)
myReverse' [ ] ys    = ys
--prime example for studying algorithmic optimization as an operation on algorithms. 

--[x] Problem 6: Determine whether or not a list is a palindrome.

myIsPalindrome :: (Eq a) => [a] -> Bool
myIsPalindrome xs = if xs == myReverse' xs [ ]
                     then True
                     else False

--[x] Problem 7: Flatten a nested list structure. 

data NestedList a = Elem a
                  | List [NestedList a]
                  deriving (Show, Eq)

myFlatten :: NestedList a -> [a]
myFlatten (List    [ ]) = [ ]
myFlatten (Elem     x ) = [x]
myFlatten (List (x:xs)) = myFlatten x ++ myFlatten (List xs)
--A tail recursive solution is needed. '++' is too slow over large lists.  

--[x] Problem 8: Compress a list by removing repeating elements.

myCompress :: (Eq a) => [a] -> [a]
myCompress [ ]  = [ ]
myCompress (x:xs)
    | x /= head xs = [x] ++ myCompress xs
    |    otherwise = myCompress xs
--A tail recursive solution is needed. '++' is too slow over large lists.  

--[x] Problem 9: Pack consecutive duplicates of list elements into sublists.

myPack :: (Eq a) => [a] -> [[a]]
myPack [ ] = [ ]
myPack [x] = [[x]]
myPack  xs = fst spanned_list : myPack (snd spanned_list) 
                where 
                spanned_list = span (==(head xs)) xs

--[x] Problem 10: Encode the run-length of consecutive duplicates in a list.

myRunLength :: (Eq a) => [a] -> [(a, Int)]
myRunLength [ ] = error "invalid input to myRunLength."
myRunLength  xs = tupler packed_list
                    where 
                    tupler = map (\ys -> (head ys, myLength ys))
                    packed_list = myPack xs 

--[x] Problem 11: Modify the result of problem 10 to send only non-singular elements as tuples, and singular elements as themselves. 
 
data CompressedString a = Single a
                        | Multiple Int a
                        deriving (Show, Eq)

myModifiedRunLength :: (Eq a) => [a] -> [CompressedString a]
myModifiedRunLength = encoder . myPack 
                        where
                        encoder = map (\ys -> if (myLength ys == 1) 
                                                then Single (head ys) 
                                                else Multiple (myLength ys) (head ys))

--[x] Problem 12: Create a function that decodes lists of compressed strings, as generated by Problem 11. In other words,
--                program the (one-way) inverse function of myModifiedRunLength.

--decode each member of the received list to be mapped over.
auxDecoder :: (Eq a) => CompressedString a -> [a]
auxDecoder (Single x) = [x]
auxDecoder (Multiple n x) = take n (repeat x)

myDecompressor :: (Eq a) => [CompressedString a] -> [a]
myDecompressor = foldr (++) [ ] . map auxDecoder

--[x] Problem 13: Implement run-length data encoding directly, without packing consecutive elements into sublists.

-- this function will never make singles, and so splits the compressed string data type into its second component.
auxAccruer :: (Eq a) => Int -> a -> [CompressedString a] -> [CompressedString a]
auxAccruer n x [ ] = [Multiple n x]
auxAccruer n x (y@(Multiple a b):ys)
    | x == b = (Multiple (n+a) x):ys
    | otherwise = (Multiple n x):y:ys

-- therefore, there is no need to include a case for a Single being input into this function.
auxSingler :: CompressedString a -> CompressedString a
auxSingler (Multiple 1 x) = Single x
auxSingler (Multiple n x) = id (Multiple n x) 

myDirectRunLength :: (Eq a) => [a] -> [CompressedString a]
myDirectRunLength = (map auxSingler) . foldr (auxAccruer 1) [ ]

--[x] Problem 14: Duplicate the elements of a list. 

--very slow option
myDuplicator :: (Eq a) => [a] -> [a]
myDuplicator = (foldl (++) [ ]) . (map auxDecoder) . foldr (auxAccruer 2) [ ] 

--faster option, entirely polymorphic across Listable types.
myDuplicator' :: [a] -> [a]
myDuplicator' [ ]    = [ ]
myDuplicator' (x:xs) = [x, x] ++ xs
--need tail recursive solution replacing '++'

--this solution is not faster than myDuplicator'. Why?
myDuplicator'' :: [a] -> [a] -> [a]
myDuplicator'' (x:xs) ys = myDuplicator'' xs (x:x:ys)
myDuplicator''    [ ] ys = myReverse' ys [ ]

--[x] Problem 15: Replicate the elements of a list a given number of times.

myReplicator :: (Eq a) => Int -> [a] -> [a]
myReplicator n
    | n  < 0 = error "negative input to myReplicator."
    | n == 0 = (\_ -> [ ])
    | n == 1 = id
    | otherwise = (foldl (++) [ ]) . (map auxDecoder) . foldr (auxAccruer n) [ ]
--need tail recursive solution replacing '++'

--[x] Problem 16: Drop every nth element from a list.
--create two implementations - one that fails when given negative integers, and one that implements negative integers by swapping endianess.
--this would mean dropping every nth element from the right when given -n as the second argument.

--somehow, I think this function could be tidied up with some monadic logic.
myDrop :: (Eq a) => [a] -> Int -> [a]
myDrop  [ ] _ = [ ]
myDrop   xs 0 = xs
myDrop    _ 1 = [ ]
myDrop   xs n 
    | n <  0 = error "negative input to myDrop."
    | n >  myLength xs = xs
    | n == myLength xs = init xs
    | otherwise = let (ys,zs) = splitAt (n-1) xs 
                   in  ys ++ (myDrop (tail zs) n) 
                     
--[ ] Problem 17: Split a list into two parts, with the length of the first part being given.

mySplit :: [a] -> Int -> ([a],[a])
mySplit    [ ]  _ = ([ ],[ ])
mySplit     xs  0 = ([ ], xs)
mySplit  (x:xs) 1 = ([x], xs) --versus (head xs, tail xs), which is faster?
mySplit     xs  n
    | n < 0 = error "negative input to mySplit."
    | n > myLength xs = (xs, [ ]) --should I throw an error here?

--curried solution
--mySplit :: Int -> [a] -> ([a],[a])
--mySplit 0 = 
--mySplit 1 = 
--mySplit n = 

--[ ] Problem 18:

--[ ] Problem 19:

--[ ] Problem 20:

--[ ] Problem 21:

--[ ] Problem 22:

--[ ] Problem 23:

--[ ] Problem 24:

--[ ] Problem 25:

--[ ] Problem 26:

--[ ] Problem 27:

--[ ] Problem 28:

--[ ] Problem 29:

--[ ] Problem 30:

--[ ] Problem 31:

--[ ] Problem 32:

--[ ] Problem 33:

--[ ] Problem 34:

--[ ] Problem 35:

--[ ] Problem 36:

--[ ] Problem 37:

--[ ] Problem 38:

--[ ] Problem 39:

--[ ] Problem 40:

--[ ] Problem 41:

--[ ] Problem 42:

--[ ] Problem 43:

--[ ] Problem 44:

--[ ] Problem 45:

--[ ] Problem 46:

--[ ] Problem 47:

--[ ] Problem 48:

--[ ] Problem 49:

--[ ] Problem 50:

--[ ] Problem 51:

--[ ] Problem 52:

--[ ] Problem 53:

--[ ] Problem 54:

--[ ] Problem 55:

--[ ] Problem 56:

--[ ] Problem 57:

--[ ] Problem 58:

--[ ] Problem 59:

--[ ] Problem 60:

--[ ] Problem 61:

--[ ] Problem 62:

--[ ] Problem 63:

--[ ] Problem 64:

--[ ] Problem 65:

--[ ] Problem 66:

--[ ] Problem 67:

--[ ] Problem 68:

--[ ] Problem 69:

--[ ] Problem 70:

--[ ] Problem 71:

--[ ] Problem 72:

--[ ] Problem 73:

--[ ] Problem 74:

--[ ] Problem 75:

--[ ] Problem 76:

--[ ] Problem 77:

--[ ] Problem 78:

--[ ] Problem 79:

--[ ] Problem 80:

--[ ] Problem 81:

--[ ] Problem 82:

--[ ] Problem 83:

--[ ] Problem 84:

--[ ] Problem 85:

--[ ] Problem 86:

--[ ] Problem 87:

--[ ] Problem 88:

--[ ] Problem 89:

--[ ] Problem 90:

--[ ] Problem 91:

--[ ] Problem 92:

--[ ] Problem 93:

--[ ] Problem 94:

--[ ] Problem 95:

--[ ] Problem 96:

--[ ] Problem 97:

--[ ] Problem 98:

--[ ] Problem 99:
