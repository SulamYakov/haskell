--[x] Problem 1: Find the last element of a list. 

myLast :: [a] -> a
myLast [ ]    = error "no last element of empty list."  
myLast [x]    = x
myLast (_:xs) = myLast xs

--[x] Problem 2: Find the next-to-last element of a list.
 
myButLast :: [a] -> a
myButLast [ ]    = error "invalid input to myButLast."
myButLast [x]    = x
myButLast [x,_]  = x
myButLast (_:xs) = myButLast xs

--[x] Problem 3: Find the k-th element of a list.

myElementAt :: Int -> [a] -> a
myElementAt k = last . (take k)  

--[x] Problem 4: Find the number of elements in a list.

myLength :: [a] -> Int 
myLength [ ]    = 0
myLength (_:xs) = 1 + myLength xs

--[x] Problem 5: Reverse a list.

myReverse :: [a] -> [a]
myReverse [ ]    = [ ]
myReverse (x:xs) = myReverse xs ++ [x]
--A tail recursive solution to make this significantly faster in large cases. 
myReverse' :: [a] -> [a] -> [a]
myReverse' (x:xs) ys = myReverse' xs (x:ys)
myReverse' [ ] ys    = ys
--prime example for studying algorithmic optimization as an operation on algorithms. 

--[x] Problem 6: Determine whether or not a list is a palindrome.

myIsPalindrome :: (Eq a) => [a] -> Bool
myIsPalindrome xs = if xs == myReverse' xs [ ]
                     then True
                     else False

--[x] Problem 7: Flatten a nested list structure. 

data NestedList a = Elem a
                  | List [NestedList a]
                  deriving (Show, Eq)

myFlatten :: NestedList a -> [a]
myFlatten (List    [ ]) = [ ]
myFlatten (Elem     x ) = [x]
myFlatten (List (x:xs)) = myFlatten x ++ myFlatten (List xs)
--A tail recursive solution is needed. '++' is too slow over large lists.  

--[x] Problem 8: Compress a list by removing repeating elements.

myCompress :: (Eq a) => [a] -> [a]
myCompress [ ]  = [ ]
myCompress (x:xs)
    | x /= head xs = [x] ++ myCompress xs
    |    otherwise = myCompress xs
--A tail recursive solution is needed. '++' is too slow over large lists.  

--[x] Problem 9: Pack consecutive duplicates of list elements into sublists.

myPack :: (Eq a) => [a] -> [[a]]
myPack [ ] = [ ]
myPack [x] = [[x]]
myPack  xs = fst spanned_list : myPack (snd spanned_list) 
                where 
                spanned_list = span (==(head xs)) xs

--[x] Problem 10: Encode the run-length of consecutive duplicates in a list.

myRunLength :: (Eq a) => [a] -> [(a, Int)]
myRunLength [ ] = error "invalid input to myRunLength."
myRunLength  xs = tupler packed_list
                    where 
                    tupler = map (\ys -> (head ys, myLength ys))
                    packed_list = myPack xs 

--[x] Problem 11: Modify the result of problem 10 to send only non-singular elements as tuples, and singular elements as themselves. 
 
data CompressedString a = Single a
                        | Multiple Int a
                        deriving (Show, Eq)

myModifiedRunLength :: (Eq a) => [a] -> [CompressedString a]
myModifiedRunLength = encoder . myPack 
                        where
                        encoder = map (\ys -> if (myLength ys == 1) 
                                                then Single (head ys) 
                                                else Multiple (myLength ys) (head ys))

--[x] Problem 12: Create a function that decodes lists of compressed strings, as generated by Problem 11. In other words,
--                program the (one-way) inverse function of myModifiedRunLength.

--decode each member of the received list to be mapped over.
auxDecoder :: CompressedString a -> [a]
auxDecoder (Single x) = [x]
auxDecoder (Multiple n x) = take n (repeat x)

myDecompressor :: [CompressedString a] -> [a]
myDecompressor = foldr (++) [ ] . map auxDecoder

--[x] Problem 13: Implement run-length data encoding directly, without packing consecutive elements into sublists.

-- this function will never make singles, and so splits the compressed string data type into its second component.
auxAccruer :: (Eq a) => Int -> a -> [CompressedString a] -> [CompressedString a]
auxAccruer n x [ ] = [Multiple n x]
auxAccruer n x (y@(Multiple a b):ys)
    | x == b = (Multiple (n+a) x):ys
    | otherwise = (Multiple n x):y:ys

-- therefore, there is no need to include a case for a Single being input into this function.
auxSingler :: CompressedString a -> CompressedString a
auxSingler (Multiple 1 x) = Single x
auxSingler (Multiple n x) = id (Multiple n x) 

myDirectRunLength :: (Eq a) => [a] -> [CompressedString a]
myDirectRunLength = (map auxSingler) . foldr (auxAccruer 1) [ ]

--[x] Problem 14: Duplicate the elements of a list. 

--very slow option
myDuplicator :: (Eq a) => [a] -> [a]
myDuplicator = (foldl (++) [ ]) . (map auxDecoder) . foldr (auxAccruer 2) [ ] 

--faster option, entirely polymorphic across Listable types.
myDuplicator' :: [a] -> [a]
myDuplicator' [ ]    = [ ]
myDuplicator' (x:xs) = [x, x] ++ xs
--need tail recursive solution replacing '++'

--this solution is not faster than myDuplicator'. Why?
myDuplicator'' :: [a] -> [a] -> [a]
myDuplicator'' (x:xs) ys = myDuplicator'' xs (x:x:ys)
myDuplicator''    [ ] ys = myReverse' ys [ ]

--[x] Problem 15: Replicate the elements of a list a given number of times.

myReplicator :: (Eq a) => Int -> [a] -> [a]
myReplicator n
    | n  < 0 = error "negative input to myReplicator."
    | n == 0 = (\_ -> [ ])
    | n == 1 = id
    | otherwise = (foldl (++) [ ]) . (map auxDecoder) . foldr (auxAccruer n) [ ]
--need tail recursive solution replacing '++'

--[x] Problem 16: Drop every nth element from a list.
--create two implementations - one that fails when given negative integers, and one that implements negative integers by swapping endianess.
--this would mean dropping every nth element from the right when given -n as the second argument.

--somehow, I think this function could be tidied up with some monadic logic.
myDrop :: [a] -> Int -> [a]
myDrop  [ ] _ = [ ]
myDrop   xs 0 = xs
myDrop    _ 1 = [ ]
myDrop   xs n 
    | n <  0 = error "negative input to myDrop."
    | n >  myLength xs = xs
    | n == myLength xs = init xs
    | otherwise = let (ys,zs) = splitAt (n-1) xs 
                   in  ys ++ (myDrop (tail zs) n) 
                     
--[ ] Problem 17: Split a list into two parts, with the length of the first part being given.

--this still doesn't work... moving on using splitAt, but will come back to this.
mySplit :: [a] -> Int -> ([a], [a])
mySplit       [ ]   _  = ([ ], [ ])
mySplit        xs   0  = ([ ],  xs)
mySplit        xs (-1) = ( init  xs , [last xs])
mySplit        xs   1  = ([head  xs],  tail xs ) --versus (x:xs) 1 = ([x], xs), which is faster?
mySplit        xs   n
    |   n   > myLength xs = error "too large of an input to mySplit."
    | (-n)  > myLength xs = error "too small of an input to mySplit."
    |   n  == myLength xs = (xs , [ ]) --equivalent to 'swap mySplit xs 0'.
    | (-n) == myLength xs = ([ ],  xs)
    |   n   < 0 = (take ((myLength xs)+n) xs,
                   myReverse' (take (-n) (myReverse' xs [ ])) [ ])
    |   n   > 0 = (take ((myLength xs)-n) xs, 
                   myReverse' (take ((myLength xs)-n) (myReverse' xs [ ])) [ ])

--this could be tidied up with a 'take' function that takes from the end of a list.
--other methods could probably be used, as well. 

--curried solution
--mySplit' :: Int -> [a] -> ([a], [a])
--mySplit'   0  = 
--mySplit' (-1) =
--mySplit'   1  = 
--mySplit'   n  = 

--[x] Problem 18: Slice a list. Given two indices, i and k, the slice is the list containing the elements 
--between the i'th and k'th element of the original list (both limits included). Start counting the elements 
--with 1. 

--this solution feels incomplete, and the error cases need to be given more depth.
--also, this needs negative index functionality.
mySlice :: [a] -> Int -> Int -> [a]
mySlice  _ 0 0 = error "invalid input to mySlice."
mySlice xs i k 
    | i < 0 = error "invalid input to mySlice."
    | k < 0 = error "invalid input to mySlice." 
    | i > k = error "invalid input to mySlice."
    | i > myLength xs = error "invalid input to mySlice."
    | k > myLength xs = error "invalid input to mySlice."
    | otherwise = map (($ xs) . myElementAt) [i..k]

--[x] Problem 19: Rotate a list about a pivot N.

myRotate :: Int -> [a] -> [a]
myRotate n xs = snd (splitAt n xs) ++ fst (splitAt n xs)

--curried solution
--myRotate' :: Int -> [a] -> [a]
--myRotate' n = 

--[x] Problem 20: Remove the N'th element from a list.

--needs to be extended to allow negative index functionality.
myRemoveAt :: [a] -> Int -> [a]
myRemoveAt  [ ] _ = [ ]
myRemoveAt   xs 0 = xs
myRemoveAt   xs 1 = tail xs
myRemoveAt   xs n 
    | n <  0 = error "negative input to myRemoveAt."
    | n >  myLength xs = xs --feels like bad functionality.. error should be thrown here.
    | n == myLength xs = init xs
    | otherwise = let (ys,zs) = splitAt (n-1) xs 
                   in  ys ++ tail zs                 
--note that this is just 'myDrop' without the recursive call.

--[x] Problem 21: Insert an element at a given position N into a list.

--needs to be extended to allow negative index functionality.
myInsertAt :: a -> [a] -> Int -> [a]
myInsertAt x xs n = let (ys, zs) = splitAt n xs
                     in  ys ++ [x] ++ zs

--[ ] Problem 22:

--[ ] Problem 23:

--[ ] Problem 24:

--[ ] Problem 25:

--[ ] Problem 26:

--[ ] Problem 27:

--[ ] Problem 28:

--[ ] Problem 29:

--[ ] Problem 30:

--[ ] Problem 31:

--[ ] Problem 32:

--[ ] Problem 33:

--[ ] Problem 34:

--[ ] Problem 35:

--[ ] Problem 36:

--[ ] Problem 37:

--[ ] Problem 38:

--[ ] Problem 39:

--[ ] Problem 40:

--[ ] Problem 41:

--[ ] Problem 42:

--[ ] Problem 43:

--[ ] Problem 44:

--[ ] Problem 45:

--[ ] Problem 46:

--[ ] Problem 47:

--[ ] Problem 48:

--[ ] Problem 49:

--[ ] Problem 50:

--[ ] Problem 51:

--[ ] Problem 52:

--[ ] Problem 53:

--[ ] Problem 54:

--[ ] Problem 55:

--[ ] Problem 56:

--[ ] Problem 57:

--[ ] Problem 58:

--[ ] Problem 59:

--[ ] Problem 60:

--[ ] Problem 61:

--[ ] Problem 62:

--[ ] Problem 63:

--[ ] Problem 64:

--[ ] Problem 65:

--[ ] Problem 66:

--[ ] Problem 67:

--[ ] Problem 68:

--[ ] Problem 69:

--[ ] Problem 70:

--[ ] Problem 71:

--[ ] Problem 72:

--[ ] Problem 73:

--[ ] Problem 74:

--[ ] Problem 75:

--[ ] Problem 76:

--[ ] Problem 77:

--[ ] Problem 78:

--[ ] Problem 79:

--[ ] Problem 80:

--[ ] Problem 81:

--[ ] Problem 82:

--[ ] Problem 83:

--[ ] Problem 84:

--[ ] Problem 85:

--[ ] Problem 86:

--[ ] Problem 87:

--[ ] Problem 88:

--[ ] Problem 89:

--[ ] Problem 90:

--[ ] Problem 91:

--[ ] Problem 92:

--[ ] Problem 93:

--[ ] Problem 94:

--[ ] Problem 95:

--[ ] Problem 96:

--[ ] Problem 97:

--[ ] Problem 98:

--[ ] Problem 99:
